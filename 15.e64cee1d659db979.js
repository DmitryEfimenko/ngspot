"use strict";(self.webpackChunkdemo=self.webpackChunkdemo||[]).push([[15],{5015:(h,m,o)=>{o.r(m),o.d(m,{default:()=>B});var l=o(177),c=o(4738),d=o(1827),t=o(4438),n=o(9417),p=o(9631),a=o(2102),f=o(6600),C=o(64),x=o(2410);const F={provide:f.es,useFactory:(e,u)=>u.get(e.showErrorsWhenInput),deps:[d.k,x.z]};let N=(()=>{class e{constructor(){this.matInput=(0,t.WQX)(p.fg,{self:!0}),this.allErrorsState=(0,t.WQX)(C.l),this.defaultErrorStateMatcher=(0,t.WQX)(f.es),this.ngOnInitRun=(0,t.vPA)(!1),this.hasErrors=!1,this.errorStateMatcher={isErrorState:()=>this.hasErrors},this.updateErrorStateEffect=(0,t.QZP)(()=>{if(!this.ngOnInitRun()||!this.matInput.ngControl)return;const{control:r}=this.matInput.ngControl;if(!r)throw new Error("Could not find control for matInput");const i=this.allErrorsState.getControlState(r);if(!i)return;const M=i.errors();Object.keys(M).length>0?(this.matInput.errorStateMatcher=this.errorStateMatcher,this.hasErrors=Object.values(M).some(J=>J)):this.matInput.errorStateMatcher=this.defaultErrorStateMatcher,this.matInput.updateErrorState()})}ngOnInit(){this.ngOnInitRun.set(!0)}static#t=this.\u0275fac=function(r){return new(r||e)};static#e=this.\u0275dir=t.FsC({type:e,selectors:[["input","matInput",""],["textarea","matInput",""],["select","matNativeControl",""],["input","matNativeControl",""],["textarea","matNativeControl",""]],standalone:!0,features:[t.Jv_([F])]})}return e})();var g=o(4311);let R=(()=>{class e extends g.G{constructor(){super(...arguments),this.resolvedControl=(0,t.vPA)(void 0),this.formField=(0,t.WQX)(a.xb,{self:!0})}ngAfterViewInit(){this.resolvedControl.set(this.formField._control.ngControl?.control??void 0)}static#t=this.\u0275fac=(()=>{let s;return function(i){return(s||(s=t.xGo(e)))(i||e)}})();static#e=this.\u0275dir=t.FsC({type:e,selectors:[["mat-form-field"]],standalone:!0,features:[t.Jv_([{provide:g.G,useExisting:e}]),t.Vt3]})}return e})();var E=o(7864),v=o(7498);function D(e,u){1&e&&(t.j41(0,"mat-error"),t.EFF(1,"Name is required"),t.k0s())}let I=(()=>{class e{constructor(){this.fb=(0,t.WQX)(n.ok),this.form=this.fb.group({name:this.fb.control("",{validators:[n.k0.required]})})}static#t=this.\u0275fac=function(r){return new(r||e)};static#e=this.\u0275cmp=t.VBU({type:e,selectors:[["ngs-with-module-demo-result"]],standalone:!0,features:[t.Jv_([(0,d.T)({showErrorsWhenInput:"dirty"})]),t.aNF],decls:6,vars:2,consts:[[3,"formGroup"],["matInput","","formControlName","name"],[4,"ngxError"]],template:function(r,i){1&r&&(t.j41(0,"form",0)(1,"mat-form-field")(2,"mat-label"),t.EFF(3,"Name"),t.k0s(),t.nrm(4,"input",1),t.DNE(5,D,2,0,"mat-error",2),t.k0s()()),2&r&&(t.Y8G("formGroup",i.form),t.R7$(5),t.Y8G("ngxError","required"))},dependencies:[n.X1,n.qT,n.me,n.BC,n.cb,n.j4,n.JD,p.fS,p.fg,a.rl,a.nJ,a.TL,N,R,E.Q,v.A],encapsulation:2,changeDetection:0})}return e})();function S(e,u){if(1&e&&(t.qex(0),t.EFF(1," This example demonstrates behavior of material error when NgxErrorsMaterialModule module is used and custom error configuration is provided. Notice the use of the "),t.j41(2,"pre"),t.EFF(3),t.nI1(4,"json"),t.k0s(),t.EFF(5," configuration. According to this configuration, the error should not be reported unless the input was modified by the user. Now, because NgxErrorsMaterialModule is used, just focusing on the input and un-focusing (marking input as touched) will NOT change the color of the label to the error state while the error is not yet shown. "),t.bVm()),2&e){const s=t.XpG();t.R7$(3),t.JRh(t.bMT(4,1,s.configSample))}}function T(e,u){1&e&&(t.qex(0),t.nrm(1,"ngs-with-module-demo-result"),t.bVm())}const y=o(1628).A;let W=(()=>{class e{constructor(){this.configSample={showErrorsWhenInput:"dirty"},this.snippets={withModule:[{fileName:"app.component.ts",content:y,language:"typescript"}]}}static#t=this.\u0275fac=function(r){return new(r||e)};static#e=this.\u0275cmp=t.VBU({type:e,selectors:[["ngs-with-module-demo"]],standalone:!0,features:[t.Jv_([(0,d.T)({showErrorsWhenInput:"dirty"})]),t.aNF],decls:3,vars:2,consts:[["header","With NgxErrorsMaterialModule module",3,"snippets","expanded"],[4,"ngsSnippetDescription"],[4,"ngsSnippetResult"]],template:function(r,i){1&r&&(t.j41(0,"ngs-code-snippets",0),t.DNE(1,S,6,3,"ng-container",1)(2,T,2,0,"ng-container",2),t.k0s()),2&r&&t.Y8G("snippets",i.snippets.withModule)("expanded",!1)},dependencies:[c.FC,c.pS,c.Gc,I,l.TG],encapsulation:2,changeDetection:0})}return e})();var w=o(6271);function A(e,u){1&e&&(t.j41(0,"mat-error"),t.EFF(1,"Name is required"),t.k0s())}let b=(()=>{class e{constructor(){this.fb=(0,t.WQX)(n.ok),this.form=this.fb.group({name:this.fb.control("",{validators:[n.k0.required]})})}static#t=this.\u0275fac=function(r){return new(r||e)};static#e=this.\u0275cmp=t.VBU({type:e,selectors:[["ngs-without-module-demo-result"]],standalone:!0,features:[t.Jv_([(0,d.T)({showErrorsWhenInput:"dirty"})]),t.aNF],decls:7,vars:2,consts:[[3,"formGroup"],["ngxErrors","name"],["matInput","","formControlName","name"],[4,"ngxError"]],template:function(r,i){1&r&&(t.j41(0,"form",0),t.qex(1,1),t.j41(2,"mat-form-field")(3,"mat-label"),t.EFF(4,"Name"),t.k0s(),t.nrm(5,"input",2),t.DNE(6,A,2,0,"mat-error",3),t.k0s(),t.bVm(),t.k0s()),2&r&&(t.Y8G("formGroup",i.form),t.R7$(6),t.Y8G("ngxError","required"))},dependencies:[n.X1,n.qT,n.me,n.BC,n.cb,n.j4,n.JD,p.fS,p.fg,a.rl,a.nJ,a.TL,w.R,E.Q,v.A],encapsulation:2,changeDetection:0})}return e})();function G(e,u){if(1&e&&(t.qex(0),t.EFF(1," This example demonstrates behavior of material error when NgxErrorsMaterialModule module is not used and custom error configuration is provided. Notice the use of the "),t.j41(2,"pre"),t.EFF(3),t.nI1(4,"json"),t.k0s(),t.EFF(5," configuration. According to this configuration, the error should not be reported unless the input was modified by the user. However, just focusing on the input and un-focusing (marking input as touched) will change the color of the label to the error state while the error is not yet shown. "),t.bVm()),2&e){const s=t.XpG();t.R7$(3),t.JRh(t.bMT(4,1,s.configSample))}}function j(e,u){1&e&&(t.qex(0),t.nrm(1,"ngs-without-module-demo-result"),t.bVm())}const O=o(4204).A;let V=(()=>{class e{constructor(){this.configSample={showErrorsWhenInput:"dirty"},this.snippets={withoutModule:[{fileName:"app.component.ts",content:O,language:"typescript"}]}}static#t=this.\u0275fac=function(r){return new(r||e)};static#e=this.\u0275cmp=t.VBU({type:e,selectors:[["ngs-without-module-demo"]],standalone:!0,features:[t.Jv_([(0,d.T)({showErrorsWhenInput:"dirty"})]),t.aNF],decls:3,vars:2,consts:[["header","Without NgxErrorsMaterialModule module",3,"snippets","expanded"],[4,"ngsSnippetDescription"],[4,"ngsSnippetResult"]],template:function(r,i){1&r&&(t.j41(0,"ngs-code-snippets",0),t.DNE(1,G,6,3,"ng-container",1)(2,j,2,0,"ng-container",2),t.k0s()),2&r&&t.Y8G("snippets",i.snippets.withoutModule)("expanded",!1)},dependencies:[c.FC,c.pS,c.Gc,b,l.TG],encapsulation:2,changeDetection:0})}return e})();var X=o(9070);const B=[{path:"",component:(()=>{class e{static#t=this.\u0275fac=function(r){return new(r||e)};static#e=this.\u0275cmp=t.VBU({type:e,selectors:[["ngs-ngx-errors-demo"]],standalone:!0,features:[t.aNF],decls:3,vars:0,template:function(r,i){1&r&&(t.j41(0,"ngs-demo-main-content"),t.nrm(1,"ngs-without-module-demo")(2,"ngs-with-module-demo"),t.k0s())},dependencies:[X.V,V,W],encapsulation:2,changeDetection:0})}return e})()},{path:"",redirectTo:"",pathMatch:"full"}]},1628:(h,m,o)=>{o.d(m,{A:()=>l});const l="import { ChangeDetectionStrategy, Component, inject } from '@angular/core';\r\nimport { FormBuilder, ReactiveFormsModule, Validators } from '@angular/forms';\r\nimport { MatInputModule } from '@angular/material/input';\r\n\r\nimport {\r\n  NGX_ERRORS_MATERIAL_DECLARATIONS,\r\n  provideNgxErrorsConfig,\r\n} from '@ngspot/ngx-errors-material';\r\n\r\n@Component({\r\n  selector: 'ngs-with-module-demo-result',\r\n  standalone: true,\r\n  imports: [\r\n    ReactiveFormsModule,\r\n    MatInputModule,\r\n    NGX_ERRORS_MATERIAL_DECLARATIONS,\r\n  ],\r\n  providers: [provideNgxErrorsConfig({ showErrorsWhenInput: 'dirty' })],\r\n  changeDetection: ChangeDetectionStrategy.OnPush,\r\n  template: `\r\n    <form [formGroup]=\"form\">\r\n      <mat-form-field>\r\n        <mat-label>Name</mat-label>\r\n\r\n        <input matInput formControlName=\"name\" />\r\n\r\n        <mat-error *ngxError=\"'required'\">Name is required</mat-error>\r\n      </mat-form-field>\r\n    </form>\r\n  `,\r\n})\r\nexport class WithModuleDemoResultComponent {\r\n  private fb = inject(FormBuilder);\r\n\r\n  form = this.fb.group({\r\n    name: this.fb.control('', { validators: [Validators.required] }),\r\n  });\r\n}\r\n"},4204:(h,m,o)=>{o.d(m,{A:()=>l});const l="import { ChangeDetectionStrategy, Component, inject } from '@angular/core';\r\nimport { FormBuilder, ReactiveFormsModule, Validators } from '@angular/forms';\r\nimport { MatInputModule } from '@angular/material/input';\r\n\r\nimport { NGX_ERRORS_DECLARATIONS, provideNgxErrorsConfig } from '@ngspot/ngx-errors';\r\n\r\n@Component({\r\n  selector: 'ngs-without-module-demo-result',\r\n  standalone: true,\r\n  imports: [ReactiveFormsModule, MatInputModule, NGX_ERRORS_DECLARATIONS],\r\n  providers: [provideNgxErrorsConfig({ showErrorsWhenInput: 'dirty' })],\r\n  changeDetection: ChangeDetectionStrategy.OnPush,\r\n  template: `\r\n    <form [formGroup]=\"form\">\r\n      <ng-container ngxErrors=\"name\">\r\n        <mat-form-field>\r\n          <mat-label>Name</mat-label>\r\n\r\n          <input matInput formControlName=\"name\" />\r\n\r\n          <mat-error *ngxError=\"'required'\">Name is required</mat-error>\r\n        </mat-form-field>\r\n      </ng-container>\r\n    </form>\r\n  `,\r\n})\r\nexport class WithoutModuleDemoResultComponent {\r\n  private fb = inject(FormBuilder);\r\n\r\n  form = this.fb.group({\r\n    name: this.fb.control('', { validators: [Validators.required] }),\r\n  });\r\n}\r\n"}}]);