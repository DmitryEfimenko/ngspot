"use strict";(self.webpackChunkdemo=self.webpackChunkdemo||[]).push([[796],{6796:(f,m,n)=>{n.r(m),n.d(m,{default:()=>P});var l=n(177),c=n(4738),p=n(1827),t=n(4438),s=n(9417),d=n(9631),u=n(2102),g=n(6600),F=n(64),C=n(2410);const D={provide:g.es,useFactory:(e,a)=>a.get(e.showErrorsWhenInput),deps:[p.k,C.z]};let M=(()=>{class e{constructor(){this.matInput=(0,t.WQX)(d.fg,{self:!0}),this.allErrorsState=(0,t.WQX)(F.l),this.defaultErrorStateMatcher=(0,t.WQX)(g.es),this.ngOnInitRun=(0,t.vPA)(!1),this.hasErrors=!1,this.errorStateMatcher={isErrorState:()=>this.hasErrors},this.updateErrorStateEffect=(0,t.QZP)(()=>{if(!this.ngOnInitRun()||!this.matInput.ngControl)return;const{control:r}=this.matInput.ngControl;if(!r)throw new Error("Could not find control for matInput");const i=this.allErrorsState.getControlState(r);if(!i)return;const x=i.errors();Object.keys(x).length>0?(this.matInput.errorStateMatcher=this.errorStateMatcher,this.hasErrors=Object.values(x).some(L=>L)):this.matInput.errorStateMatcher=this.defaultErrorStateMatcher,this.matInput.updateErrorState()})}ngOnInit(){this.ngOnInitRun.set(!0)}static#t=this.\u0275fac=function(r){return new(r||e)};static#e=this.\u0275dir=t.FsC({type:e,selectors:[["input","matInput",""],["textarea","matInput",""],["select","matNativeControl",""],["input","matNativeControl",""],["textarea","matNativeControl",""]],standalone:!0,features:[t.Jv_([D])]})}return e})();var E=n(4311);let T=(()=>{class e extends E.G{constructor(){super(...arguments),this.resolvedControl=(0,t.vPA)(void 0),this.formField=(0,t.WQX)(u.xb,{self:!0})}ngAfterViewInit(){this.resolvedControl.set(this.formField._control.ngControl?.control??void 0)}static#t=this.\u0275fac=(()=>{let o;return function(i){return(o||(o=t.xGo(e)))(i||e)}})();static#e=this.\u0275dir=t.FsC({type:e,selectors:[["mat-form-field"]],standalone:!0,features:[t.Jv_([{provide:E.G,useExisting:e}]),t.Vt3]})}return e})();var v=n(7864),h=n(7498);let y=(()=>{class e extends v.Q{static#t=this.\u0275fac=(()=>{let o;return function(i){return(o||(o=t.xGo(e)))(i||e)}})();static#e=this.\u0275dir=t.FsC({type:e,selectors:[["","ngxError",""]],exportAs:["ngxError"],standalone:!0,features:[t.Vt3]})}return e})(),N=(()=>{class e extends h.A{static#t=this.\u0275fac=(()=>{let o;return function(i){return(o||(o=t.xGo(e)))(i||e)}})();static#e=this.\u0275dir=t.FsC({type:e,selectors:[["form"]],exportAs:["ngxErrorsForm"],standalone:!0,features:[t.Jv_([{provide:h.A,useExisting:e}]),t.Vt3]})}return e})();function R(e,a){1&e&&(t.j41(0,"mat-error"),t.EFF(1,"Name is required"),t.k0s())}let I=(()=>{class e{constructor(){this.fb=(0,t.WQX)(s.ok),this.form=this.fb.group({name:this.fb.control("",{validators:[s.k0.required]})})}static#t=this.\u0275fac=function(r){return new(r||e)};static#e=this.\u0275cmp=t.VBU({type:e,selectors:[["ngs-with-module-demo-result"]],standalone:!0,features:[t.Jv_([(0,p.T)({showErrorsWhenInput:"dirty"})]),t.aNF],decls:6,vars:2,consts:[[3,"formGroup"],["matInput","","formControlName","name"],[4,"ngxError"]],template:function(r,i){1&r&&(t.j41(0,"form",0)(1,"mat-form-field")(2,"mat-label"),t.EFF(3,"Name"),t.k0s(),t.nrm(4,"input",1),t.DNE(5,R,2,0,"mat-error",2),t.k0s()()),2&r&&(t.Y8G("formGroup",i.form),t.R7$(5),t.Y8G("ngxError","required"))},dependencies:[s.X1,s.qT,s.me,s.BC,s.cb,s.j4,s.JD,d.fS,d.fg,u.rl,u.nJ,u.TL,M,T,y,N],encapsulation:2,changeDetection:0})}return e})();function S(e,a){if(1&e&&(t.qex(0),t.EFF(1," This example demonstrates behavior of material error when ngx-errors-material library is used and custom error configuration is provided. Notice the use of the "),t.j41(2,"pre"),t.EFF(3),t.nI1(4,"json"),t.k0s(),t.EFF(5," configuration. According to this configuration, the error should not be reported unless the input was modified by the user. Now, because ngx-errors-material lib is used, just focusing on the input and un-focusing (marking input as touched) will NOT change the color of the label to the error state while the error is not yet shown. "),t.bVm()),2&e){const o=t.XpG();t.R7$(3),t.JRh(t.bMT(4,1,o.configSample))}}function W(e,a){1&e&&(t.qex(0),t.nrm(1,"ngs-with-module-demo-result"),t.bVm())}const w=n(1628).A;let b=(()=>{class e{constructor(){this.configSample={showErrorsWhenInput:"dirty"},this.snippets={withModule:[{fileName:"app.component.ts",content:w,language:"typescript"}]}}static#t=this.\u0275fac=function(r){return new(r||e)};static#e=this.\u0275cmp=t.VBU({type:e,selectors:[["ngs-with-module-demo"]],standalone:!0,features:[t.Jv_([(0,p.T)({showErrorsWhenInput:"dirty"})]),t.aNF],decls:3,vars:2,consts:[["header","With ngx-errors-material lib",3,"snippets","expanded"],[4,"ngsSnippetDescription"],[4,"ngsSnippetResult"]],template:function(r,i){1&r&&(t.j41(0,"ngs-code-snippets",0),t.DNE(1,S,6,3,"ng-container",1)(2,W,2,0,"ng-container",2),t.k0s()),2&r&&t.Y8G("snippets",i.snippets.withModule)("expanded",!1)},dependencies:[c.FC,c.pS,c.Gc,I,l.TG],encapsulation:2,changeDetection:0})}return e})();var A=n(6271);function G(e,a){1&e&&(t.j41(0,"mat-error"),t.EFF(1,"Name is required"),t.k0s())}let j=(()=>{class e{constructor(){this.fb=(0,t.WQX)(s.ok),this.form=this.fb.group({name:this.fb.control("",{validators:[s.k0.required]})})}static#t=this.\u0275fac=function(r){return new(r||e)};static#e=this.\u0275cmp=t.VBU({type:e,selectors:[["ngs-without-module-demo-result"]],standalone:!0,features:[t.Jv_([(0,p.T)({showErrorsWhenInput:"dirty"})]),t.aNF],decls:7,vars:2,consts:[[3,"formGroup"],["ngxErrors","name"],["matInput","","formControlName","name"],[4,"ngxError"]],template:function(r,i){1&r&&(t.j41(0,"form",0),t.qex(1,1),t.j41(2,"mat-form-field")(3,"mat-label"),t.EFF(4,"Name"),t.k0s(),t.nrm(5,"input",2),t.DNE(6,G,2,0,"mat-error",3),t.k0s(),t.bVm(),t.k0s()),2&r&&(t.Y8G("formGroup",i.form),t.R7$(6),t.Y8G("ngxError","required"))},dependencies:[s.X1,s.qT,s.me,s.BC,s.cb,s.j4,s.JD,d.fS,d.fg,u.rl,u.nJ,u.TL,A.R,v.Q,h.A],encapsulation:2,changeDetection:0})}return e})();function O(e,a){if(1&e&&(t.qex(0),t.EFF(1," This example demonstrates behavior of material error when ngx-errors-material lib is not used and custom error configuration is provided. Notice the use of the "),t.j41(2,"pre"),t.EFF(3),t.nI1(4,"json"),t.k0s(),t.EFF(5," configuration. According to this configuration, the error should not be reported unless the input was modified by the user. However, just focusing on the input and un-focusing (marking input as touched) will change the color of the label to the error state while the error is not yet shown. "),t.bVm()),2&e){const o=t.XpG();t.R7$(3),t.JRh(t.bMT(4,1,o.configSample))}}function B(e,a){1&e&&(t.qex(0),t.nrm(1,"ngs-without-module-demo-result"),t.bVm())}const V=n(4204).A;let X=(()=>{class e{constructor(){this.configSample={showErrorsWhenInput:"dirty"},this.snippets={withoutModule:[{fileName:"app.component.ts",content:V,language:"typescript"}]}}static#t=this.\u0275fac=function(r){return new(r||e)};static#e=this.\u0275cmp=t.VBU({type:e,selectors:[["ngs-without-module-demo"]],standalone:!0,features:[t.Jv_([(0,p.T)({showErrorsWhenInput:"dirty"})]),t.aNF],decls:3,vars:2,consts:[["header","Without ngx-errors-material lib",3,"snippets","expanded"],[4,"ngsSnippetDescription"],[4,"ngsSnippetResult"]],template:function(r,i){1&r&&(t.j41(0,"ngs-code-snippets",0),t.DNE(1,O,6,3,"ng-container",1)(2,B,2,0,"ng-container",2),t.k0s()),2&r&&t.Y8G("snippets",i.snippets.withoutModule)("expanded",!1)},dependencies:[c.FC,c.pS,c.Gc,j,l.TG],encapsulation:2,changeDetection:0})}return e})();var J=n(9070);const P=[{path:"",component:(()=>{class e{static#t=this.\u0275fac=function(r){return new(r||e)};static#e=this.\u0275cmp=t.VBU({type:e,selectors:[["ngs-ngx-errors-demo"]],standalone:!0,features:[t.aNF],decls:3,vars:0,template:function(r,i){1&r&&(t.j41(0,"ngs-demo-main-content"),t.nrm(1,"ngs-without-module-demo")(2,"ngs-with-module-demo"),t.k0s())},dependencies:[J.V,X,b],encapsulation:2,changeDetection:0})}return e})()},{path:"",redirectTo:"",pathMatch:"full"}]},1628:(f,m,n)=>{n.d(m,{A:()=>l});const l="import { ChangeDetectionStrategy, Component, inject } from '@angular/core';\r\nimport { FormBuilder, ReactiveFormsModule, Validators } from '@angular/forms';\r\nimport { MatInputModule } from '@angular/material/input';\r\n\r\nimport {\r\n  NGX_ERRORS_MATERIAL_DECLARATIONS,\r\n  provideNgxErrorsConfig,\r\n} from '@ngspot/ngx-errors-material';\r\n\r\n@Component({\r\n  selector: 'ngs-with-module-demo-result',\r\n  standalone: true,\r\n  imports: [\r\n    ReactiveFormsModule,\r\n    MatInputModule,\r\n    ...NGX_ERRORS_MATERIAL_DECLARATIONS,\r\n  ],\r\n  providers: [provideNgxErrorsConfig({ showErrorsWhenInput: 'dirty' })],\r\n  changeDetection: ChangeDetectionStrategy.OnPush,\r\n  template: `\r\n    <form [formGroup]=\"form\">\r\n      <mat-form-field>\r\n        <mat-label>Name</mat-label>\r\n\r\n        <input matInput formControlName=\"name\" />\r\n\r\n        <mat-error *ngxError=\"'required'\">Name is required</mat-error>\r\n      </mat-form-field>\r\n    </form>\r\n  `,\r\n})\r\nexport class WithModuleDemoResultComponent {\r\n  private fb = inject(FormBuilder);\r\n\r\n  form = this.fb.group({\r\n    name: this.fb.control('', { validators: [Validators.required] }),\r\n  });\r\n}\r\n"},4204:(f,m,n)=>{n.d(m,{A:()=>l});const l="import { ChangeDetectionStrategy, Component, inject } from '@angular/core';\r\nimport { FormBuilder, ReactiveFormsModule, Validators } from '@angular/forms';\r\nimport { MatInputModule } from '@angular/material/input';\r\n\r\nimport { NGX_ERRORS_DECLARATIONS, provideNgxErrorsConfig } from '@ngspot/ngx-errors';\r\n\r\n@Component({\r\n  selector: 'ngs-without-module-demo-result',\r\n  standalone: true,\r\n  imports: [ReactiveFormsModule, MatInputModule, ...NGX_ERRORS_DECLARATIONS],\r\n  providers: [provideNgxErrorsConfig({ showErrorsWhenInput: 'dirty' })],\r\n  changeDetection: ChangeDetectionStrategy.OnPush,\r\n  template: `\r\n    <form [formGroup]=\"form\">\r\n      <ng-container ngxErrors=\"name\">\r\n        <mat-form-field>\r\n          <mat-label>Name</mat-label>\r\n\r\n          <input matInput formControlName=\"name\" />\r\n\r\n          <mat-error *ngxError=\"'required'\">Name is required</mat-error>\r\n        </mat-form-field>\r\n      </ng-container>\r\n    </form>\r\n  `,\r\n})\r\nexport class WithoutModuleDemoResultComponent {\r\n  private fb = inject(FormBuilder);\r\n\r\n  form = this.fb.group({\r\n    name: this.fb.control('', { validators: [Validators.required] }),\r\n  });\r\n}\r\n"}}]);