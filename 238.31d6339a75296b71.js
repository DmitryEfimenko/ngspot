"use strict";(self.webpackChunkdemo=self.webpackChunkdemo||[]).push([[238],{238:(h,a,o)=>{o.r(a),o.d(a,{default:()=>R});var u=o(4755),m=o(6273),c=o(1610),t=o(2223),n=o(9401),p=o(8097),f=o(8541),x=o(1217),C=o(4296),N=o(727),D=o(8505),y=o(4991);let g=(()=>{class r{constructor(s,e){if(this.matInput=s,this.overriddenShowWhen=e,this.subs=new N.w0,!this.matInput.ngControl)return;const i=this.matInput.ngControl.control,X=e.controlOverridden$.pipe((0,D.b)(J=>{if(i===J){const O=this.overriddenShowWhen.get(i);this.matInput.errorStateMatcher={isErrorState:()=>!!O.length}}})).subscribe();this.subs.add(X)}ngOnDestroy(){this.subs.unsubscribe()}static#t=this.\u0275fac=function(e){return new(e||r)(t.Y36(p.Nt,2),t.Y36(y.S))};static#r=this.\u0275dir=t.lG2({type:r,selectors:[["input","matInput",""],["textarea","matInput",""],["select","matNativeControl",""],["input","matNativeControl",""],["textarea","matNativeControl",""]]})}return r})(),w=(()=>{class r{static#t=this.\u0275fac=function(e){return new(e||r)};static#r=this.\u0275mod=t.oAB({type:r});static#e=this.\u0275inj=t.cJS({providers:[{provide:x.rD,useFactory:(s,e)=>e.get(s.showErrorsWhenInput),deps:[c.e,C.M]}],imports:[n.UX]})}return r})();var M=o(9142),v=o(3597),E=o(2696),l=o(9114);let I=(()=>{class r{constructor(){this.fb=(0,t.f3M)(n.qu),this.form=this.fb.group({name:this.fb.control("",{validators:[n.kI.required]})})}static#t=this.\u0275fac=function(e){return new(e||r)};static#r=this.\u0275cmp=t.Xpm({type:r,selectors:[["ngs-with-module-demo-result"]],standalone:!0,features:[t._Bn([{provide:c.e,useValue:{showErrorsWhenInput:"dirty"}}]),t.jDz],decls:8,vars:1,consts:[[3,"formGroup"],["matInput","","formControlName","name"],["ngxErrors","name"],["ngxError","required"]],template:function(e,i){1&e&&(t.TgZ(0,"form",0)(1,"mat-form-field")(2,"mat-label"),t._uU(3,"Name"),t.qZA(),t._UZ(4,"input",1),t.TgZ(5,"mat-error",2)(6,"span",3),t._uU(7,"Name is required"),t.qZA()()()()),2&e&&t.Q6J("formGroup",i.form)},dependencies:[n.UX,n._Y,n.Fj,n.JJ,n.JL,n.sg,n.u,f.G,M.$,v.u,E.A,w,g,p.c,p.Nt,l.KE,l.hX,l.TO],encapsulation:2,changeDetection:0})}return r})();function T(r,d){if(1&r&&(t.ynx(0),t._uU(1," This example demonstrates behavior of material error when NgxErrorsMaterialModule module is used and custom error configuration is provided. Notice the use of the "),t.TgZ(2,"pre"),t._uU(3),t.ALo(4,"json"),t.qZA(),t._uU(5," configuration. According to this configuration, the error should not be reported unless the input was modified by the user. Now, because NgxErrorsMaterialModule is used, just focusing on the input and un-focusing (marking input as touched) will NOT change the color of the label to the error state while the error is not yet shown. "),t.BQk()),2&r){const s=t.oxw();t.xp6(3),t.Oqu(t.lcZ(4,1,s.configSample))}}function Z(r,d){1&r&&(t.ynx(0),t._UZ(1,"ngs-with-module-demo-result"),t.BQk())}const W=o(1033).Z;let S=(()=>{class r{constructor(){this.configSample={showErrorsWhenInput:"dirty"},this.snippets={withModule:[{fileName:"app.component.ts",content:W,language:"typescript"}]}}static#t=this.\u0275fac=function(e){return new(e||r)};static#r=this.\u0275cmp=t.Xpm({type:r,selectors:[["ngs-with-module-demo"]],standalone:!0,features:[t._Bn([{provide:c.e,useValue:{showErrorsWhenInput:"dirty"}}]),t.jDz],decls:3,vars:1,consts:[["title","Without NgxErrorsMaterialModule module",3,"snippets"],[4,"ngsSnippetDescription"],[4,"ngsSnippetResult"]],template:function(e,i){1&e&&(t.TgZ(0,"ngs-code-snippets",0),t.YNc(1,T,6,3,"ng-container",1),t.YNc(2,Z,2,0,"ng-container",2),t.qZA()),2&e&&t.Q6J("snippets",i.snippets.withModule)},dependencies:[m.rM,m._,m.I6,I,u.Ts],encapsulation:2,changeDetection:0})}return r})(),b=(()=>{class r{constructor(){this.fb=(0,t.f3M)(n.qu),this.form=this.fb.group({name:this.fb.control("",{validators:[n.kI.required]})})}static#t=this.\u0275fac=function(e){return new(e||r)};static#r=this.\u0275cmp=t.Xpm({type:r,selectors:[["ngs-without-module-demo-result"]],standalone:!0,features:[t._Bn([{provide:c.e,useValue:{showErrorsWhenInput:"dirty"}}]),t.jDz],decls:8,vars:1,consts:[[3,"formGroup"],["matInput","","formControlName","name"],["ngxErrors","name"],["ngxError","required"]],template:function(e,i){1&e&&(t.TgZ(0,"form",0)(1,"mat-form-field")(2,"mat-label"),t._uU(3,"Name"),t.qZA(),t._UZ(4,"input",1),t.TgZ(5,"mat-error",2)(6,"span",3),t._uU(7,"Name is required"),t.qZA()()()()),2&e&&t.Q6J("formGroup",i.form)},dependencies:[n.UX,n._Y,n.Fj,n.JJ,n.JL,n.sg,n.u,f.G,M.$,v.u,E.A,p.c,p.Nt,l.KE,l.hX,l.TO],encapsulation:2,changeDetection:0})}return r})();function A(r,d){if(1&r&&(t.ynx(0),t._uU(1," This example demonstrates behavior of material error when NgxErrorsMaterialModule module is not used and custom error configuration is provided. Notice the use of the "),t.TgZ(2,"pre"),t._uU(3),t.ALo(4,"json"),t.qZA(),t._uU(5," configuration. According to this configuration, the error should not be reported unless the input was modified by the user. However, just focusing on the input and un-focusing (marking input as touched) will change the color of the label to the error state while the error is not yet shown. "),t.BQk()),2&r){const s=t.oxw();t.xp6(3),t.Oqu(t.lcZ(4,1,s.configSample))}}function F(r,d){1&r&&(t.ynx(0),t._UZ(1,"ngs-without-module-demo-result"),t.BQk())}const U=o(5759).Z;let j=(()=>{class r{constructor(){this.configSample={showErrorsWhenInput:"dirty"},this.snippets={withoutModule:[{fileName:"app.component.ts",content:U,language:"typescript"}]}}static#t=this.\u0275fac=function(e){return new(e||r)};static#r=this.\u0275cmp=t.Xpm({type:r,selectors:[["ngs-without-module-demo"]],standalone:!0,features:[t._Bn([{provide:c.e,useValue:{showErrorsWhenInput:"dirty"}}]),t.jDz],decls:3,vars:1,consts:[["title","Without NgxErrorsMaterialModule module",3,"snippets"],[4,"ngsSnippetDescription"],[4,"ngsSnippetResult"]],template:function(e,i){1&e&&(t.TgZ(0,"ngs-code-snippets",0),t.YNc(1,A,6,3,"ng-container",1),t.YNc(2,F,2,0,"ng-container",2),t.qZA()),2&e&&t.Q6J("snippets",i.snippets.withoutModule)},dependencies:[m.rM,m._,m.I6,b,u.Ts],encapsulation:2,changeDetection:0})}return r})();var B=o(8034);const R=[{path:"",component:(()=>{class r{static#t=this.\u0275fac=function(e){return new(e||r)};static#r=this.\u0275cmp=t.Xpm({type:r,selectors:[["ngs-ngx-errors-demo"]],standalone:!0,features:[t.jDz],decls:3,vars:0,template:function(e,i){1&e&&(t.TgZ(0,"ngs-demo-main-content"),t._UZ(1,"ngs-without-module-demo")(2,"ngs-with-module-demo"),t.qZA())},dependencies:[B._,j,S],encapsulation:2,changeDetection:0})}return r})()},{path:"",redirectTo:"",pathMatch:"full"}]},1033:(h,a,o)=>{o.d(a,{Z:()=>u});const u="import { ChangeDetectionStrategy, Component, inject } from '@angular/core';\r\nimport { FormBuilder, ReactiveFormsModule, Validators } from '@angular/forms';\r\nimport { MatInputModule } from '@angular/material/input';\r\n\r\nimport {\r\n  ErrorsConfiguration,\r\n  IErrorsConfiguration,\r\n  NgxErrorsModule,\r\n} from '@ngspot/ngx-errors';\r\nimport { NgxErrorsMaterialModule } from '@ngspot/ngx-errors-material';\r\n\r\n@Component({\r\n  selector: 'ngs-with-module-demo-result',\r\n  standalone: true,\r\n  imports: [\r\n    ReactiveFormsModule,\r\n    NgxErrorsModule,\r\n    NgxErrorsMaterialModule,\r\n    MatInputModule,\r\n  ],\r\n  providers: [\r\n    {\r\n      provide: ErrorsConfiguration,\r\n      useValue: <IErrorsConfiguration>{ showErrorsWhenInput: 'dirty' },\r\n    },\r\n  ],\r\n  changeDetection: ChangeDetectionStrategy.OnPush,\r\n  template: `\r\n    <form [formGroup]=\"form\">\r\n      <mat-form-field>\r\n        <mat-label>Name</mat-label>\r\n\r\n        <input matInput formControlName=\"name\" />\r\n\r\n        <mat-error ngxErrors=\"name\">\r\n          <span ngxError=\"required\">Name is required</span>\r\n        </mat-error>\r\n      </mat-form-field>\r\n    </form>\r\n  `,\r\n})\r\nexport class WithModuleDemoResultComponent {\r\n  private fb = inject(FormBuilder);\r\n\r\n  form = this.fb.group({\r\n    name: this.fb.control('', { validators: [Validators.required] }),\r\n  });\r\n}\r\n"},5759:(h,a,o)=>{o.d(a,{Z:()=>u});const u="import { ChangeDetectionStrategy, Component, inject } from '@angular/core';\r\nimport { FormBuilder, ReactiveFormsModule, Validators } from '@angular/forms';\r\nimport { MatInputModule } from '@angular/material/input';\r\n\r\nimport {\r\n  ErrorsConfiguration,\r\n  IErrorsConfiguration,\r\n  NgxErrorsModule,\r\n} from '@ngspot/ngx-errors';\r\n\r\n@Component({\r\n  selector: 'ngs-without-module-demo-result',\r\n  standalone: true,\r\n  imports: [ReactiveFormsModule, NgxErrorsModule, MatInputModule],\r\n  providers: [\r\n    {\r\n      provide: ErrorsConfiguration,\r\n      useValue: <IErrorsConfiguration>{ showErrorsWhenInput: 'dirty' },\r\n    },\r\n  ],\r\n  changeDetection: ChangeDetectionStrategy.OnPush,\r\n  template: `\r\n    <form [formGroup]=\"form\">\r\n      <mat-form-field>\r\n        <mat-label>Name</mat-label>\r\n\r\n        <input matInput formControlName=\"name\" />\r\n\r\n        <mat-error ngxErrors=\"name\">\r\n          <span ngxError=\"required\">Name is required</span>\r\n        </mat-error>\r\n      </mat-form-field>\r\n    </form>\r\n  `,\r\n})\r\nexport class WithoutModuleDemoResultComponent {\r\n  private fb = inject(FormBuilder);\r\n\r\n  form = this.fb.group({\r\n    name: this.fb.control('', { validators: [Validators.required] }),\r\n  });\r\n}\r\n"}}]);